import { storage } from '../storage';

export interface GeminiConfig {
  apiKey: string;
  model: string;
  endpoint: string;
}

export interface GeminiResponse {
  candidates?: Array<{
    content: {
      parts: Array<{ text: string }>;
    };
    finishReason: string;
  }>;
  error?: {
    code: number;
    message: string;
    status: string;
  };
}

export class GeminiService {
  private static async getConfig(): Promise<GeminiConfig | null> {
    try {
      const enabled = await storage.getSettingByKey('gemini_enabled');
      if (!enabled || enabled.value !== 'true') {
        return null;
      }

      const apiKey = await storage.getSettingByKey('gemini_api_key');
      const model = await storage.getSettingByKey('gemini_model');
      const endpoint = await storage.getSettingByKey('gemini_endpoint');

      if (!apiKey?.value || !model?.value || !endpoint?.value) {
        throw new Error('Missing Gemini configuration');
      }

      return {
        apiKey: apiKey.value,
        model: model.value,
        endpoint: endpoint.value
      };
    } catch (error) {
      console.error('Gemini configuration error:', error);
      return null;
    }
  }

  static async generateContent(prompt: string, systemInstruction?: string): Promise<string> {
    const config = await this.getConfig();
    if (!config) {
      throw new Error('Gemini service not configured or disabled');
    }

    try {
      const requestBody: any = {
        contents: [{
          parts: [{ text: prompt }]
        }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 1024,
        }
      };

      if (systemInstruction) {
        requestBody.systemInstruction = {
          parts: [{ text: systemInstruction }]
        };
      }

      const response = await fetch(
        `${config.endpoint}${config.model}:generateContent?key=${config.apiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody)
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
      }

      const data: GeminiResponse = await response.json();
      
      if (data.error) {
        throw new Error(`Gemini error: ${data.error.message}`);
      }

      if (!data.candidates || data.candidates.length === 0) {
        throw new Error('No content generated by Gemini');
      }

      const text = data.candidates[0].content.parts
        .map(part => part.text)
        .join(' ');

      return text;
    } catch (error) {
      console.error('Gemini API error:', error);
      throw new Error(`Failed to generate content: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  static async analyzeElectoralData(data: any): Promise<string> {
    const systemInstruction = `You are an expert electoral observer analyst. Analyze electoral data and provide insights on irregularities, patterns, and recommendations for election integrity.`;
    
    const prompt = `Analyze this electoral observation data:

${JSON.stringify(data, null, 2)}

Please provide:
1. Statistical analysis of voting patterns
2. Identification of potential irregularities
3. Comparison with expected norms
4. Risk assessment and recommendations
5. Areas requiring immediate attention`;

    return await this.generateContent(prompt, systemInstruction);
  }

  static async generateReportSummary(reports: any[]): Promise<string> {
    const systemInstruction = `You are an electoral monitoring specialist. Summarize observation reports to highlight key findings and actionable insights.`;
    
    const prompt = `Summarize these electoral observation reports:

${reports.map((report, i) => `Report ${i + 1}: ${JSON.stringify(report)}`).join('\n\n')}

Provide:
- Executive summary
- Critical incidents
- Overall assessment
- Recommendations for election officials`;

    return await this.generateContent(prompt, systemInstruction);
  }

  static async detectAnomalies(metrics: any[]): Promise<string> {
    const systemInstruction = `You are an AI specialist in electoral anomaly detection. Identify unusual patterns and potential fraud indicators in electoral data.`;
    
    const prompt = `Analyze these electoral metrics for anomalies:

${JSON.stringify(metrics, null, 2)}

Focus on:
- Statistical outliers
- Unusual voting patterns
- Turnout irregularities
- Time-based anomalies
- Geographic inconsistencies`;

    return await this.generateContent(prompt, systemInstruction);
  }

  static async validateConfiguration(): Promise<{ valid: boolean; message: string }> {
    const config = await this.getConfig();
    if (!config) {
      return { valid: false, message: 'Gemini service not configured' };
    }

    try {
      const testContent = await this.generateContent('Test connection to Gemini API');
      if (testContent && testContent.length > 0) {
        return { valid: true, message: 'Gemini API connection successful' };
      }
      return { valid: false, message: 'No response from Gemini API' };
    } catch (error) {
      return { 
        valid: false, 
        message: `Connection failed: ${error instanceof Error ? error.message : 'Unknown error'}` 
      };
    }
  }
}